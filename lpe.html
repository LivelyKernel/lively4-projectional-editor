<script src="https://lively-kernel.org/lively4/lively4-projectional-editor/dependencies.js"></script>

<script>
  System.import('https://lively-kernel.org/lively4/lively4-projectional-editor/lpe.js').then(
    function(lpe) {
      //lpe.transformCodeOnClick('code-source', 'ast-transform-button', 'ast-target');

      const test_types = [
        'Program',
        'VariableDeclaration',
        'VariableDeclarator',
        'Identifier',
        'NumericLiteral',
        'StringLiteral',
        'Literal',
        'BinaryExpression'
      ];
      var toolbox = '<xml>';

      for(var i = 0; i < test_types.length; i++) {
          const type = test_types[i];
          const type_name = 'babel_' + type;
          Blockly.Blocks[type_name] = lpe.blockDefinitionForNodeType(type);
          toolbox += '  <block type="' + type_name + '"></block>';
      }

      toolbox += '</xml>';
      
      let Blockly = lpe_lib.blockly;
      const workspace = Blockly.inject('blocklyDiv', {
          toolbox: toolbox,
          collapse: true,
          scrollbars: true
      });
      
      function onChange(event) {  
      
        if (event.type == Blockly.Events.MOVE) {  
        
           let block = workspace.getBlockById(event.blockId);
           
           if (block) {
              updateBlockConnections(block);            
           }       
        }
      }
      workspace.addChangeListener(onChange);
      
      function updateBlockConnections(block) {
          let prevConnected = block.previousConnection &&
              block.previousConnection.isConnected();
           let nextConnected = block.nextConnection &&
              block.nextConnection.isConnected();
           let outConnected = block.outputConnection &&
              block.outputConnection.isConnected();
                   
           if (prevConnected || nextConnected) {  
              block.setOutput(false, null);
           } else if (outConnected) {
              block.setPreviousStatement(false, null);
                  block.setNextStatement(false, null);                
           } else {          
              block.setOutput(true, null);
              block.setPreviousStatement(true, null);
                  block.setNextStatement(true, null);
           }
      }

      $("#button").on("click", () => {
          workspace.clear();
          try {
              lpe.createBlocksForCode($('#input').val(), workspace);
          } catch (e) {
              console.log(e);
          }
      });
    }
  )
</script>

<!--<juicy-ace-editor id="code-source" style="width:400px"></juicy-ace-editor>
<button id="ast-transform-button">Transform</button>
<pre id="ast-target"></pre>-->

<h1>Blockly Test</h1>

<textarea rows="5" cols="80" id="input">Put your code here...</textarea>

<button id="button">Transform</button>

<div id="blocklyDiv" style="height: 480px; width: 100%;"></div>